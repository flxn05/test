<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bewegungssensor — Roter Ball</title>
<style>
  html,body{
    height:100%;
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background: linear-gradient(180deg,#0b1020 0%, #111827 100%);
    color:#fff;
    -webkit-user-select:none;
    user-select:none;
    overflow:hidden;
  }

  .wrap{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:16px;
    padding:20px;
    box-sizing:border-box;
  }

  .stage{
    position:relative;
    width:clamp(260px, 80vw, 720px);
    height:clamp(460px, 80vh, 980px);
    max-height:calc(100vh - 160px);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:18px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    overflow:hidden;
    touch-action:none;
  }

  /* Der Ball */
  .ball{
    position:absolute;
    width:64px;
    height:64px;
    border-radius:50%;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background: radial-gradient(circle at 35% 30%, #ff6b6b 0%, #e11 40%, #8b0000 100%);
    box-shadow:
      0 0 40px rgba(255,80,80,0.55),
      0 8px 20px rgba(0,0,0,0.6),
      0 0 120px rgba(255,40,40,0.18) inset;
    will-change: transform;
  }

  /* UI */
  .controls {
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:center;
    margin-top:10px;
  }

  button {
    background: linear-gradient(180deg,#ff5b5b,#e04848);
    color:white;
    border:0;
    padding:10px 14px;
    border-radius:10px;
    font-size:15px;
    box-shadow: 0 6px 18px rgba(224,72,72,0.25);
  }

  .info {
    font-size:13px;
    text-align:center;
    opacity:0.9;
    max-width:720px;
  }

  .small {
    font-size:12px;
    opacity:0.8;
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1 style="margin:0;font-weight:600">Roter Ball — Sensor Demo</h1>
    <div class="info">Tippe auf <strong>„Sensor erlauben“</strong> (falls nötig), dann kannst du dein iPhone kippen — der Ball folgt einer einfachen Gravitation.</div>

    <div class="stage" id="stage" aria-hidden="false">
      <div id="ball" class="ball" role="img" aria-label="Roter Ball"></div>
    </div>

    <div class="controls">
      <button id="reqBtn">Sensor erlauben</button>
      <button id="resetBtn">Zur Mitte</button>
    </div>

    <div class="info small" id="status">Status: Bereit</div>
  </div>

<script>
/*
  Funktionalität:
  - Fordert bei Bedarf Permission an (iOS).
  - Hört auf deviceorientation oder devicemotion.
  - Nutzt accelerationIncludingGravity wenn verfügbar, sonst greift es auf orientation-Winkel zurück.
  - Einfache physik: velocity += gravity * factor; position += velocity * dt; mit Bounds und Dämpfung.
*/

(function(){
  const ballEl = document.getElementById('ball');
  const stage = document.getElementById('stage');
  const reqBtn = document.getElementById('reqBtn');
  const resetBtn = document.getElementById('resetBtn');
  const statusEl = document.getElementById('status');

  let width, height, radius;
  function measure(){
    const rect = stage.getBoundingClientRect();
    width = rect.width;
    height = rect.height;
    // Ballradius nach CSS (64px / 2)
    radius = 32;
  }
  measure();
  window.addEventListener('resize', measure);

  // Physikzustand
  let pos = { x: width/2, y: height/2 };
  let vel = { x: 0, y: 0 };
  let lastTime = null;

  // Empfindlichkeit & Dämpfung
  const gravityScale = 120;    // multipliziert die gemessene Gravitation -> fühlbarere Bewegung
  const damping = 0.85;        // Dämpfung bei Kollision
  const airFriction = 0.995;   // leichte Luftreibung aufs Velocity

  // aktuelle gemessene "gravity" in Bildschirmkoordinaten (px/s^2 ungefähnert)
  let g = { x:0, y:0 };

  function setStatus(s){
    statusEl.textContent = 'Status: '+s;
  }

  // Event-Handler: DeviceMotion bevorzugt
  function handleDeviceMotion(e){
    // accelerationIncludingGravity ist am direktesten für "Kippen" als Schwerkraftvector
    const a = e.accelerationIncludingGravity;
    if (a && typeof a.x === 'number') {
      // Gerätes Achsen -> Bildschirmachsen mappen
      // Hinweis: je nach Gerät/Orientierung eventuell invertieren. Für Portrait-Mode:
      // a.x: links(-) / rechts(+)
      // a.y: vor(-) / zurück(+)   --- auf vielen Geräten ist y invertiert, wir negieren für passende Richtung
      // Wir nehmen einfache Mapping: screenX = a.x, screenY = -a.y
      g.x = (a.x) || 0;
      g.y = -(a.y || 0);
    }
  }

  // Fallback: deviceorientation -> berechne Gravitation aus beta/gamma
  function handleDeviceOrientation(e){
    // e.beta: rotation around X axis (tilt front-to-back) -90..90
    // e.gamma: rotation around Y axis (tilt left-to-right) -90..90
    // Wir berechnen eine approximative gravity vector:
    const beta = e.beta || 0;   // front/back
    const gamma = e.gamma || 0; // left/right

    // Konvertiere Winkel (deg) in einen groben "g"-Wert:
    // sin(angle) approximiert Anteil der Schwerkraft in Achse
    const radBeta = beta * Math.PI / 180;
    const radGamma = gamma * Math.PI / 180;
    g.x = Math.sin(radGamma) * 9.81;   // left-right component in m/s^2
    g.y = Math.sin(radBeta) * 9.81 * -1; // invertiert, damit Kippen nach vorne Ball nach unten zieht
  }

  // Haupt-Render/Update Loop
  function step(ts){
    if (!lastTime) lastTime = ts;
    const dt = Math.min(0.05, (ts - lastTime) / 1000); // in s, clamp für stability
    lastTime = ts;

    // transformiere gemessene g (m/s^2) in px/s^2: multiply by gravityScale
    const gx = g.x * gravityScale;
    const gy = g.y * gravityScale;

    // Integration (semi-implicit Euler)
    vel.x += gx * dt;
    vel.y += gy * dt;

    // Luftreibung
    vel.x *= airFriction;
    vel.y *= airFriction;

    pos.x += vel.x * dt;
    pos.y += vel.y * dt;

    // Kollision mit Grenzen (einfacher Bounce)
    if (pos.x - radius < 0) {
      pos.x = radius;
      vel.x = -vel.x * damping;
    } else if (pos.x + radius > width) {
      pos.x = width - radius;
      vel.x = -vel.x * damping;
    }

    if (pos.y - radius < 0) {
      pos.y = radius;
      vel.y = -vel.y * damping;
    } else if (pos.y + radius > height) {
      pos.y = height - radius;
      vel.y = -vel.y * damping;
    }

    // Anwenden der Position (CSS transform)
    const tx = pos.x - width/2;
    const ty = pos.y - height/2;
    ballEl.style.transform = `translate(${tx}px, ${ty}px)`;

    requestAnimationFrame(step);
  }

  // Startet Animation
  requestAnimationFrame(step);

  // Permission-Logik (besonders für iOS)
  async function requestPermissionIfNeeded(){
    // Manche iOS-Versionen erfordern DeviceMotionEvent.requestPermission()
    try{
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        setStatus('Fordere motion permission an...');
        const response = await DeviceMotionEvent.requestPermission();
        if (response !== 'granted') {
          setStatus('Motion-Permission verweigert.');
          return false;
        }
        // Manche Geräte brauchen auch DeviceOrientation permission (seltener)
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const resp2 = await DeviceOrientationEvent.requestPermission();
            if (resp2 !== 'granted') {
              // orientation evtl nicht erlaubt, aber motion war erlaubt
              console.warn('Orientation permission not granted:', resp2);
            }
          } catch (err) {
            console.warn('DeviceOrientation permission error', err);
          }
        }
        setStatus('Sensorzugriff erlaubt.');
        return true;
      } else {
        // Browser ohne Request-Permission API (Android Chrome, Desktop, ältere iOS)
        setStatus('Sensorzugriff (wenn verfügbar) aktiviert — keine explizite Erlaubnis nötig.');
        return true;
      }
    }catch(err){
      console.error(err);
      setStatus('Fehler beim Anfordern der Erlaubnis.');
      return false;
    }
  }

  // Aktiviert Eventlistener (einmal)
  let listenersActive = false;
  function activateListeners(){
    if (listenersActive) return;
    listenersActive = true;

    // Devicemotion (prferenz)
    window.addEventListener('devicemotion', handleDeviceMotion, { passive:true });

    // fallback / zusätzlich deviceorientation
    window.addEventListener('deviceorientation', handleDeviceOrientation, { passive:true });

    setStatus('Sensorlistener aktiv — kipp das Gerät!');
  }

  // Button handlers
  reqBtn.addEventListener('click', async () => {
    setStatus('Bitte kurz warten...');
    const ok = await requestPermissionIfNeeded();
    if (ok) activateListeners();
  });

  resetBtn.addEventListener('click', () => {
    // zurück zur Mitte
    measure();
    pos = { x: width/2, y: height/2 };
    vel = { x: 0, y: 0 };
    setStatus('Zurückgesetzt.');
  });

  // Automatisch versuchen, Listener zu aktivieren (für Desktop testing)
  // Aber nicht, wenn explizite permission API vorhanden (dann warten auf Button)
  if (typeof DeviceMotionEvent !== 'undefined' &&
      typeof DeviceMotionEvent.requestPermission === 'function') {
    // auf iOS: warte auf Benutzeraktion -> Button
    setStatus('Tippe "Sensor erlauben" (iOS benötigt Erlaubnis).');
  } else {
    // Versuch direkt; viele Android/Chrome erlauben ohne Anfrage
    activateListeners();
  }

  // Optional: Drag fallback (falls kein Sensor)
  let dragging = false;
  let dragOffset = {x:0,y:0};
  stage.addEventListener('pointerdown', (ev)=>{
    dragging = true;
    const rect = stage.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    dragOffset.x = px - pos.x;
    dragOffset.y = py - pos.y;
    setStatus('Ziehe den Ball (Fallback).');
  });
  window.addEventListener('pointermove', (ev)=>{
    if (!dragging) return;
    const rect = stage.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    pos.x = px - dragOffset.x;
    pos.y = py - dragOffset.y;
    vel.x = 0; vel.y = 0;
  });
  window.addEventListener('pointerup', ()=>{ dragging = false; setStatus('Tippe "Sensor erlauben" für echte Sensoren.'); });

})();
</script>
</body>
</html>
